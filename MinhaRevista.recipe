from calibre.web.feeds.news import BasicNewsRecipe

class MinhaRevista(BasicNewsRecipe):
    title = 'Minha Revista Diaria'
    description = 'Revista de Noticias e Novidades.'
    language = 'pt-BR'
    encoding = 'utf-8'

    # --- DIRETRIZES (Mantidas) ---
    oldest_article = 9999
    max_articles_per_feed = 5
    no_stylesheets = True

    # --- DIRETRIZ DE CONFIANCA (Mantida) ---
    # Forca o Calibre a usar o conteudo do RSS para o "THE NEWS"
    use_embedded_content = True
    
    # --- REMOVEMOS 'keep_only_tags' ---
    # keep_only_tags = [dict(name='article')] # REMOVIDO

    # Lista de feeds
    feeds = [
        ('JW - Novidades PT', 'https://www.jw.org/pt/Novidades/rss/WhatsNewWebArticles/feed.xml'),
        ('JW - Whats New EN', 'https://www.jw.org/en/whats-new/rss/WhatsNewWebArticles/feed.xml'),
        ('THE NEWS (Beehiiv)', 'https://rss.beehiiv.com/feeds/j9teVW9Qmi.xml'),
    ]

    # --- O "INTERRUPTOR" HIBRIDO (Mantido) ---
    # Decide o que fazer para cada artigo
    def print_version(self, url):
        if "beehiiv.com" in url:
            # Para "THE NEWS": Nao baixe a pagina, use o RSS
            return None
        else:
            # Para "JW.org": Baixe a pagina (para scraping)
            return url

    # --- A NOVA LOGICA DE LIMPEZA (Substitui 'keep_only_tags') ---
    def postprocess_html(self, soup, first_fetch):
        #
        
        # 1. Tentamos encontrar a tag <article> (que sabemos que o JW.org usa)
        body = soup.find('article')
        
        # 2. Se encontrarmos a tag...
        if body:
            # ...limpamos a pagina e usamos apenas essa tag.
            # (Isso so vai acontecer nos artigos do JW.org)
            soup.body.clear()
            soup.body.append(body)
            return soup
        
        # 3. Se nao encontrarmos a tag <article>...
        # ... (o que significa que e o conteudo do "THE NEWS" vindo do RSS)
        # ... nao fazemos NADA e retornamos o 'soup' original, intacto.
        return soup
